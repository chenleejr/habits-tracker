# 习惯追踪应用技术实现文档

## 1. 技术架构概述

本项目采用现代化的前端技术栈，基于React和TypeScript构建，使用Zustand进行状态管理，Tailwind CSS处理样式。

* **前端框架**：React 18 + TypeScript

* **状态管理**：Zustand

* **样式框架**：Tailwind CSS

* **构建工具**：Vite

* **数据存储**：localStorage

* **图表库**：Recharts

## 2. 项目结构

```
src/
├── components/          # 可复用组件
│   ├── Layout.tsx      # 应用布局组件
│   ├── TaskCard.tsx    # 任务卡片组件
│   ├── LevelProgress.tsx # 等级进度组件
│   ├── HealthBar.tsx   # 血量条组件
│   └── ParticleEffect.tsx # 粒子效果组件
├── pages/              # 页面组件
│   ├── Home.tsx        # 首页
│   ├── TaskManager.tsx # 任务管理页
│   ├── Statistics.tsx  # 统计页面
│   └── Settings.tsx    # 设置页面
├── store/              # 状态管理
│   └── useAppStore.ts  # 主要状态存储
├── utils/              # 工具函数
│   └── points.ts       # 积分和等级计算
├── types/              # 类型定义
│   └── index.ts        # 主要类型定义
└── App.tsx             # 应用入口
```

## 3. 核心组件设计

### 3.1 状态管理 (useAppStore.ts)

```typescript
interface AppStore {
  // 数据状态
  tasks: Task[];
  completions: Completion[];
  userData: UserData;
  
  // 核心方法
  loadData: () => void;
  addTask: (task: Omit<Task, 'id'>) => void;
  updateTask: (id: string, updates: Partial<Task>) => void;
  deleteTask: (id: string) => void;
  completeTask: (taskId: string) => void;
  
  // RPG系统方法
  applyDailyPenalty: (date: string) => PenaltyResult;
  checkAndApplyPenalties: () => void;
  testPenaltySystem: () => PenaltyResult;
}
```

**关键实现细节：**

* 使用Zustand的`persist`中间件实现数据持久化

* 在`loadData`时自动触发惩罚检查

* 积分和血量更新时同步计算等级变化

### 3.2 血量系统 (HealthBar.tsx)

```typescript
interface HealthBarProps {
  health: number;
  maxHealth: number;
  showWarning?: boolean;
}
```

**技术特点：**

* 使用CSS渐变实现血量条视觉效果

* 根据血量百分比动态调整颜色

* 低血量时显示警告图标和状态

* 响应式设计，适配不同屏幕尺寸

### 3.3 粒子效果系统 (ParticleEffect.tsx)

```typescript
interface ParticleEffectProps {
  isActive: boolean;
  sourcePosition: { x: number; y: number };
  targetPosition: { x: number; y: number };
  onComplete: () => void;
}
```

**实现要点：**

* 使用React Portal渲染到body，避免容器限制

* CSS动画实现粒子轨迹和淡出效果

* 支持自定义起始和目标位置

* 动画完成后自动清理DOM元素

### 3.4 任务卡片 (TaskCard.tsx)

**核心功能：**

* 显示任务信息（名称、描述、类型、星级）

* 完成按钮交互

* 触发完成动画的位置计算

* 支持编辑和删除操作

## 4. 数据模型设计

### 4.1 核心类型定义

```typescript
interface Task {
  id: string;
  name: string;
  description?: string;
  type: 'required' | 'optional';
  difficulty: 1 | 2 | 3 | 4 | 5;
  createdAt: string;
}

interface Completion {
  id: string;
  taskId: string;
  completedAt: string;
  points: number;
}

interface UserData {
  totalPoints: number;
  level: number;
  currentStreak: number;
  longestStreak: number;
  health: number;  // RPG血量系统
  settings: {
    theme: 'light' | 'dark';
    notifications: boolean;
  };
}
```

### 4.2 积分和等级计算 (points.ts)

**核心算法：**

```typescript
// 任务积分计算
export const calculateTaskPoints = (difficulty: number): number => {
  return difficulty * 5; // 1星=5分，5星=25分
};

// 等级计算
export const getLevelInfo = (totalPoints: number) => {
  const level = Math.floor(totalPoints / 100) + 1;
  const currentLevelPoints = totalPoints % 100;
  const pointsToNextLevel = 100 - currentLevelPoints;
  
  return { level, currentLevelPoints, pointsToNextLevel };
};

// 血量恢复计算
export const calculateHealthRestore = (difficulty: number): number => {
  return difficulty * 2; // 难度×2的血量恢复
};

// 惩罚计算
export const calculateDailyPenalty = (incompleteTasks: Task[]): number => {
  return incompleteTasks
    .filter(task => task.type === 'required')
    .reduce((total, task) => total + (task.difficulty * 5), 0);
};
```

## 5. RPG血量系统实现

### 5.1 惩罚机制

**触发时机：**

* 应用启动时自动检查（`loadData`方法中）

* 手动测试（设置页面测试按钮）

**实现逻辑：**

```typescript
applyDailyPenalty: (date: string) => {
  const dayTasks = get().tasks;
  const dayCompletions = get().completions.filter(
    c => c.completedAt.startsWith(date)
  );
  
  const incompleteTasks = dayTasks.filter(task => 
    task.type === 'required' && 
    !dayCompletions.some(c => c.taskId === task.id)
  );
  
  if (incompleteTasks.length > 0) {
    const penalty = calculateDailyPenalty(incompleteTasks);
    const newHealth = Math.max(0, get().userData.health - penalty);
    
    set(state => ({
      userData: { ...state.userData, health: newHealth }
    }));
    
    return { penalty, incompleteTasks, newHealth };
  }
  
  return { penalty: 0, incompleteTasks: [], newHealth: get().userData.health };
}
```

### 5.2 血量恢复机制

\*\*触发条件：\*\*完成任务时自动触发

**实现细节：**

```typescript
completeTask: (taskId: string) => {
  // ... 原有逻辑
  
  // 血量恢复
  const healthRestore = calculateHealthRestore(task.difficulty);
  const newHealth = Math.min(100, userData.health + healthRestore);
  
  set(state => ({
    userData: { ...state.userData, health: newHealth }
  }));
}
```

## 6. UI组件技术实现

### 6.1 血量条样式

```css
/* 血量条容器 */
.health-bar {
  @apply w-full h-4 bg-gray-200 rounded-full overflow-hidden;
}

/* 血量填充 */
.health-fill {
  @apply h-full transition-all duration-500 ease-out;
  background: linear-gradient(90deg, #ef4444, #f87171);
}

/* 警告状态 */
.health-warning {
  @apply animate-pulse;
}
```

### 6.2 粒子效果CSS

```css
.particle {
  position: absolute;
  width: 8px;
  height: 8px;
  background: #3b82f6;
  border-radius: 50%;
  pointer-events: none;
  z-index: 1000;
}

.particle-animate {
  animation: particleMove 1s ease-out forwards;
}

@keyframes particleMove {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(var(--dx), var(--dy)) scale(0);
    opacity: 0;
  }
}
```

## 7. 性能优化

### 7.1 状态管理优化

* 使用Zustand的选择器避免不必要的重渲染

* 数据持久化使用防抖机制减少localStorage写入

* 大数据列表使用虚拟滚动（如需要）

### 7.2 动画性能

* 粒子效果使用CSS动画而非JavaScript动画

* 使用`transform`和`opacity`属性确保硬件加速

* 动画完成后及时清理DOM元素

### 7.3 代码分割

* 页面组件使用React.lazy实现懒加载

* 图表组件按需加载

* 第三方库使用动态导入

## 8. 测试和调试

### 8.1 测试功能

**惩罚系统测试：**

```typescript
testPenaltySystem: () => {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  const yesterdayStr = yesterday.toISOString().split('T')[0];
  
  return get().applyDailyPenalty(yesterdayStr);
}
```

### 8.2 调试工具

* 开发环境下在控制台暴露store实例

* 详细的错误日志和状态追踪

* 数据导出功能便于问题排查

## 9. 部署和构建

### 9.1 构建配置

* 使用Vite进行快速构建

* 生产环境代码压缩和优化

* 静态资源CDN部署

### 9.2 环境配置

* 开发、测试、生产环境分离

* 环境变量管理

* 自动化部署流程

## 10. 未来扩展计划

### 10.1 功能扩展

* 更多RPG元素（装备、技能树等）

* 社交功能（好友、排行榜）

* 数据同步（云端存储）

### 10.2 技术升级

* PWA支持（离线使用）

* 移动端原生应用

* 服务端API集成

## 11. 关键技术决策

### 11.1 为什么选择Zustand

* 轻量级，学习成本低

* TypeScript支持良好

* 内置持久化中间件

* 性能优秀，避免过度渲染

### 11.2 为什么使用localStorage

* 简单可靠的本地存储方案

* 无需服务端支持

* 数据完全由用户控制

* 支持离线使用

### 11.3 动画实现选择

* CSS动画性能优于JavaScript动画

* React Portal确保动画不受容器限制

* 硬件加速提升流畅度

